# MATH3801 数学规划 Course Project (Group 5)

## Tasks

### 任务 1: 灰度图像的字典学习模型及算法

项目的第一个任务由三个子任务组成

- 根据 `(2.8)` 或其他方法设计您的字典学习模型. 但如果您使用任何现有成功，则应提供必要的参考文献! 
- 设计求解模型的优化算法，并提供详细的推导. （选做：理论分析），应提供必要的参考资料. 
- 对于三幅灰度图像，输出使用上述模型和算法学习的词典，并提供具体的设置参数. 

**Tricks** 

1. 使用重叠 patch;
2. 去除 patches 的 DC 分量（ patch 的平均值）;
3. 归一化色块的对比度（使色块的范数为 1）. 

还有其他可用的技巧，您可以通过查看文献发现它们. 
您还可以探索不同的补丁大小并找到最佳的补丁大小（如果存在），但应该注意定义这种“最优性”的标准是什么？

### 任务 2 : 彩色图像

将任务 1 中的模型推广到彩色图像. 对于彩色图像，我们有不同的颜色空间，例如 RGB 颜色空间，这是最自然的方式，因为它是我们感知颜色的方式. 可以考虑其他空间，包括 CIELab、YCbCr 或 HSI 颜色空间. 

您可以根据自己的喜好选择色彩空间，但要记住的一个问题是，如果您选择除 RGB 之外的其他颜色空间，则该空间中的噪声统计特性将会改变！

### 任务 3 : 图像去噪

第三个任务是图像去噪. 在 `data.zip` 文件中，对于 McM 数据集的每张图像，除了干净的图像之外，还有一张噪声图像. 因此，对于这个任务，使用第一个任务中的字典学习方法来进行图像去噪问题. 为此，我们有以下子任务

- 使用学到的字典导出或描述您设计的图像去噪方法的细节;
- 可以考虑测量去噪结果性能的指标 PSNR（峰值信噪比，越高越好），其定义是
  $$
  \text{MSE} = \frac{\sum_{i,j} (x^{\dagger}_{i, j} - \bar{x}_{i, j})^2}{N} ,\; \text{PSNR} = 10 \log_{10} \frac{255^2}{\text{MSE}}
  $$
  其中 $ x^{\dagger} $ 是干净图像，$\bar{x}$ 是去噪图像，$N$ 是像素总数. 对于彩色图像，计算每个 R/G/B 通道的 PSNR（如果使用不同的颜色空间，则在该空间中去噪，然后返回 RGB 空间）. 

（选做）对于上面的子任务，如图 3 所示，总共有 18 张图像，我们可以单独处理每张图像并重复 18 次. 另一方面，我们也可以将 18 张图像放在一起，只实现一次去噪流程. 然而，这种配置的规模将会非常大，可能需要很长的时间来优化. 此外，字典中的原子数量应该足够大，以捕获 18 个图像的不同特征. 有两种可能的技巧可以克服这两个困难

- 为了减少问题的规模，我们可以从每个图像中选择一个补丁子集并将它们组合在一起. 接下来的问题就变成了如何从每个图像中选择补丁. 
- 为了从图像中捕获特征，我们可以增加原子数量，例如图 2 所示的 256 个或更多. 

### 任务 4：未知的基本事实

在上述任务中，字典是从干净的图像中学习的，这在大多数实际场景中是不可能的. 因此，对于给定的噪声图像，设计一个可以同时或单独执行字典学习和图像去噪的模型，输出 PSNR 值. 应提供模型和算法的详细信息.

## K-SVD 算法

1. **初始化字典**: 

    选取 DCT（离散余弦变换）原子作为初始字典，字典的大小为 $n \times 2n$，其中 $n$ 为 patch 的大小; 为了实现稀疏表示，选取 $2n$ 个原子组成过完备字典，并进行归一化. 

2. **稀疏编码**: 对 patches 中的每条 patch，使用 OMP 算法进行稀疏编码.
    
3. **更新字典**：逐步更新字典中的原子（基向量）

   - **选取样本**：选取使用当前原子表示的样本. 
   - **更新原子**：对残差进行梯度下降，更新原子. 

4. **重复迭代**：重复步骤 2, 3，直到满足停止条件（达到最大迭代次数 / 字典不再发生显著变化）

### 稀疏编码: OMP 算法

设输入信号为 $y$，字典为 $D$，稀疏表示向量为 $x$. OMP 算法目标是找到最优的稀疏表示 $x$ s.t. $y = Dx$. OMP 算法的流程如下：

- **初始化**: 设 $x = 0$，$r = y$. 
- **迭代**：
   1. 选择最相关的原子: 找到字典 $D$ 中与残差 $r$ 最相关（内积最大）的基向量，假设是第 $k$ 个. 
   2. 更新: $x_k = x_k + d_k^T r$; $r = r - d_k^T r \cdot d_k$. 
   3. 检查条件：重复步骤 2, 3，检查 $x$ 稀疏度、残差大小是否满足精度要求，若有一项满足，则停止迭代. 

### 字典更新

从字典中选择原子 $d_k$，设利用此原子进行稀疏编码的样本为 $Y_k$

1. **选取字典中的原子**: 对于每一个字典中的原子（基向量），依次进行更新. 设第 $k$ 步更新原子 $d_k$.
2. **选取相关样本**: 对于当前待更新的原子，找到使用该原子进行稀疏编码的样本。

    设 $ I_k = \{ j: x_jk \neq 0 \} $，令 $ Y_k = Y_{I_k} $ 表示使用原子 $d_k$ 进行稀疏编码的样本，$X_k = X_{I_k \times k} $ 表示相应稀疏编码的系数.

3. **更新原子**: 通过梯度下降法优最小化残差，以更新当前选定的原子

    目标问题为
    $$
    \min_{d \in \mathbb{R}^{\mathrm{P}}} \Phi(d) = \frac{1}{2} \| Y_k - d_k X_k \|_F^2
    $$

    其中 $ \nabla \Phi (d) = - (Y_k - d_k X_k) X_k^T $

4. **重复迭代**: 对所有字典中的原子重复 1-3，直到满足停止条件（如达到最大迭代次数或字典变化不大）。



## 文件管理方式: `Git` （以下来自 ChatGPT ）

使用 `Git` 可以通过命令行或使用图形用户界面（GUI）工具。我会先介绍基本的命令行用法：

### 1. **安装与配置 `Git`**：

在您的系统上安装Git。您可以从[Git官方网站](https://git-scm.com/)下载适合您操作系统的安装程序，并按照安装向导进行安装。

[参考文献](https://blog.csdn.net/mukes/article/details/115693833)

在安装 `Git` 后，首先需要配置用户信息：

```bash
git config --global user.name "Your Name"
git config --global user.email "your_email@example.com"
```

这会将您的名字和邮箱关联到您的 `Git` 操作中，以便提交时进行标识。

### 2. **此仓库**：

如果您想要克隆（即复制）一个现有的Git仓库到本地，可以使用以下命令：

```bash
git clone <repository_url>
```

`<repository_url>`是本仓库的 URL，可在 `<> Code` 菜单中找到，有 HTML 和 SSH 两种路径。如果您有 SSH 密钥，建议使用 SSH 路径，否则使用 HTML 路径。

#### 2.1 SSH 密钥配置（推荐）

参考 [Github 官方文档](https://docs.github.com/zh/authentication/connecting-to-github-with-ssh)

### 3. **提交更改**：

VS Code 提供了较为完整的 `Git` 支持，您可以在左侧的 `Source Control` 栏中看到当前仓库的状态。在您对文件进行更改后，可以在 `Source Control` 栏中点击 `+` 按钮将更改添加到暂存区，然后在 `...` 按钮中选择 `Commit` 进行提交。在提交时，您需要填写提交信息，以便其他人了解您的更改。提交信息应当简明扼要，但又能够清晰地表达您的更改。

#### **特别注意：向远程仓库推送会覆盖原文件，请在完成一项任务后再推送！**
